---
title: 인터뷰 간략 정리
date: 2022-09-26
description: 인터뷰 간략정리
tags:
  - JS
---

- 프로그래밍 언어

  - 자바스크립트 언어가 어떤 언어인지 설명해주세요

    자바스크립트는 싱글 스레드이면서 비동기 언어입니다. 객체지향 언어이지만 클래스가 아닌 프로토 타입 상속을 기반으로 하는 언어입니다.
    변수 타입이 해지지 않은 언어입니다. 함수가 일급 객체인 언어이기 때문에 함수에 함수를 매개변수로 넣거나 반환할 수도 있습니다.

- 자바스크립트 타입과 값

  - 자바스크립트의 타입은 어떤 종류가 있나요?

    Bigint, String, Number, Null, Undefined, Symbol, Boolean, Object

  - 0.1 + 0.2 ≠ 0.3 이 현상이 왜 그런지 설명해주세요

    JS에서 소수를 저장하는 방식에서 미세한 오차가 생기기 때문입니다.

    -> 추가 설명 부호, 진수, 가수로 각각 1, 11, 52비트를 차지하는데 52비트의 가수의 덧셈에서 미세한 차이가 생깁니다.

    - 자바스크립트에서는 어떻게 해결해야할까요?

    반올림을하는 Math 메서드 등을 이용해서 해결 가능합니다.

  - null과 undefined가 무엇이고 어떤 차이가 있는 지 설명해주세요

    Null은 사용자가 직접 비었음을 표시한 것이고 undefined는 값이 지정되지 않아 비어있음을 말합니다.

  - Bigint에 대해 설명해주세요

    number로 나타낼 수 있는 수보다 큰 수를 나타내는 자료형입니다.

  - Symbol은 어떤 역할을 하나요

    객체의 Key로 Symbol이 있으면 이터러블을 이용해서 객체 내부 Key를 모두 언급해도 Symbol로 만든 Key값은 언급되지 않습니다. 정보의 은닉화가 가능해집니다.

  - 얕은 복사와 깊은 복사에 대해 설명해주세요

    얕은 복사는 복사한 객체 내부의 객체들의 메모리 주소를 복사하기 때문에 다른 객체에서 해당 메모리를 수정할 경우 얕은 복사한 객체가 변경될 수도 있지만, 깊은 복사는 메모리가 아닌 변수의 데이터를 모두 복사하는 것이기 때문에 독립되어 있습니다.

    - 깊은 복사를 할 수 있는 방법을 이야기해보세요

    재귀함수를 이용해여 각 객체 자료형이 올 경우 각 객체에 맞춰서 복사를 합니다.

- 선언

  - var와 let의 차이를 설명해주세요

  var은 호이스팅 과정에서 undefined로 초기화되지만 let은 그렇지 않습니다. 또한 let의 경우 블록 스코프를 가지고 있지만 var은 가지고 있지 않아
  for문이나 if 문 안에서 선언된 var은 외부에서도 사용 가능하게 됩니다.

  - const 선언을 지향해야 하는 이유가 무엇일까요?

    생각치 못한 곳에서 값이 변하는 것을 방지할 수 있습니다.

    - const의 불변성은 어떤 도움을 주게 되는걸까?

      조사중

  - TDZ에 대해 설명해주세요

    코드가 실행된 후부터 let이나 const에 값이 할당되기 전까지의 구역으로 이때 let이나 const로 선언될 변수가 언급되면
    typeError이 생기게 됩니다.

- 함수

  - 함수란 무엇일까요?

    실행해야하는 코드를 담고 있는 일급 객체입니다. 특정 코드를 재사용하거나 가시적으로 코드를 읽기 편하게 하기 위해 사용 가능 합니다.

  - 잘 만들어진 함수의 기준은 어떻게 될까요?

    목적이 명확하고 확장이 쉬운 함수입니다.

  - 함수 선언문과 화살표 함수의 차이에 대해 설명해주세요

    함수 선언문의 this는 기본적으로 전역 객체를 칭하지만 메소드로 사용될 경우 메소드를 소지한 객체를 칭합니다.
    화살표 함수의 경우 바로 상위 스코프를 칭하게 됩니다.

    화살표 함수는 prototype 프로퍼티를 가지지 않기 때문에 생성자로 이용이 불가능합니다.

  - 일급함수 대한 개념을 설명해주세요

    함수가 매개변수로 사용하거나 반환할 수 있는 객체로 사용되는 함수입니다.

  - this의 역할에 대해 설명해주세요

  - this를 바인딩할 수 있는 방법은 어떤 것들이 있을까요?

    apply, call, bind => bind는 해당 매개변수를 기본적으로 사용하는 새로운 함수를 만듬

  - 생성자 함수는 어떤 역할을 하나요?

  - 콜백함수의 개념에 대해 설명해주세요

- 실행 컨텍스트와 스코프, 클로저

  - 실행 컨텍스트란 무엇인가요?

    실행 컨텍스트는 크게 함수 실행 컨텍스트와 전역실행 컨텍스트로 나뉘는데 코드가 실행되면
    우선 전역실행 컨텍스트가 실행되고 함수를 만나게 되면 해당 함수 실행 컨텍스트가 쌓이게 됩니다.
    그러면 LIFO 법칙에 따라서 JS엔진은 해당 실행 컨텍스트를 처리하게 됩니다.

    실행 컨텍스트는 생성단계와 실행단계로 나뉘는데 생성단계에서는 함수 내부의 함수, 변수를 저장할
    변수객체를 저장하는 변수 객체 생성, 스코프 생성, this 생성 단계를 거치게 됩니다.

    생성단계 이후 실행단계에서 실행 컨텍스트가 실행되게 됩니다.

  - 콜 스택이 무엇인지 설명해주세요

    JS 엔진 특성상 실행 컨텍스트가 완료될 순서대로 쌓이는 저장공간입니다.

  - 호이스팅은 왜 일어나는 걸까요?

    변수 생성과 할당이 동시에 일어나지 않기 때문입니다.

  - 스코프에 의 개념에 대해 설명해주세요

    JS의 특징상 함수나 변수가 유효한 범위가 정해지게 되는데 이를 스코프라고 합니다.

  - Lexical Scope는 무엇일까요?

    렉시컬 스코프는 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라서 작동하는 스코프입니다.

  - 스코프 체인은 무엇이죠?

    JS는 하위 함수 실행 컨텍스트에서 상위 함수 실행 컨텍스트의 정보에 접근할 수 있습니다.
    즉, 스코프는 실행 컨텍스트의 중첩에 의해서 계층적으로 연결되게 되는데 이를 스코프 체인이라고 합니다.

  - 클로저의 개념에 대해 설명해주세요

    클로저는 함수 실행 컨텍스트의 lexical scope를 기억하여 접근할 수 있게 해주는 함수입니다.

  - 클로저와 스코프는 어떤 연관관계를 갖고 있을까요?

    스코프 범위에서 벗어난 곳에서도 클로저를 이용하면 내부 lexical scope에 접근할 수가 있습니다.

- 프로토타입

  - 객체란 무엇일까요?

    객체는 원시값이 아닌 자료형으로 Key와 value로 이루어진 값을 가지거나 함수를 매서드로 가지고 있는 자료형입니다.

  - 객체가 생성되는 과정을 설명해주세요

    1. 생성자 함수 호출
    2. 생성자 함수에 정의된 내용을 바탕으로 인스턴스 생성
    3. 생성자 함수의 Prototype을 참조하는 \_\_proto\_\_가 인스턴스에 할당됨

  - 인스턴스는 무엇일까요?

    인스턴스란 생성자 함수로 인하여 만들어진 객체를 말합니다.

  - 프로토타입이란 무엇일까요?

    생성자 함수가 가지고 있는 속성으로 생성자 함수를 이용해서 만들 인스턴스들이 해당 프로토타입을 참조하여 공통된 메소드를 이용 가능합니다.

  - 프로토타입과 객체지향 이야기가 나오는 이유가 뭘까요?

    객체지향 프로그래밍의 핵심 개념으로 상속이 있습니다. 어떤 객체의 프로퍼티 혹은 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말합니다.
    JS의 경우 이를 상속이 아닌 상위 프로퍼티에 대한 참조를 이용하여 구현했습니다.

  - 클래스 기반 객체지향과 프로토타입 기반 객체지향의 차이점은 어떤게 있을까요?

  조사중

  - 프로토타입 상속에 대해 설명해주세요

    생성자 함수는 기본적으로 Prototype를 가지게 되고 \_\_proto\_\_를 통해 상위 Prototype를 참조하게 됩니다.
    해당 생성자 함수를 통해 만들어진 인스턴스는 생성자 함수의 Prototype를 참조하게 되는데 생성자 함수의 Prototype을 통해
    상위 Prototype을 참조할 수 있는 점에서 상위 Prototype의 매서드를 상속받는 것과 비슷한 효과를 가질 수 있습니다.

  - prototype과 **\*\*proto**의 차이는 어떤게 있을까요?\*\*

    prototype은 생성자 함수 혹은 해당 함수가 가지게 되는 것이고 \_\_proto\_\_은 인스턴스 혹은 생성자 함수가 참조하는 상위 프로토타입입니다.

  - constructor 프로퍼티는 어떤 역할을 할까요?

    constructor은 생성자 함수를 참조합니다. 인스턴스의 원형을 알아볼 때 사용할 수 있습니다.

  - overriding 이란 무엇일까요?

    상위 프로토타입이 가지고 있는 매서드를 재정의하여 하위 프로토타입에서 사용하는 것입니다.

  - 프로토타입 체이닝이란 무엇일까요?

    인스턴스의 매서드 혹은 프로퍼티를 호출할 경우 해당 정보가 없으면 상위 프로토타입을 타고 올라가는 특징을 말합니다.

- 클래스

  - Object.create() 메서드에 대해 설명해주세요

    - 클래스와 어떤 관련이 있을까요?

    조사 중

  - 일반적인 클래스의 의미는 무엇일까요?

    공통적인 요소를 지니는 개체들을 말하며 하위 클레스는 상위 클래스의 매서드나 프로퍼티를 사용할 수가 있습니다.
    JS의 경우 이를 프로토 타입체인을 이용해서 구현했습니다.

  - 자바스크립트의 클래스는 어떤 특징을 갖는 클래스일까요?

    JS는 프로토타입과 클로저를 이용하여 클래스를 구현했습니다.

  - 클래스 내에 static 키워드가 선언된 정적 메서드는 기본 메서드와 어떤 차이점을 갖고 있을까요?

    기본 메서드의 경우 프로토타입 체인을 통해 하위 클래스에서 사용이 가능하지만 정적 메서드의 경우 해당 클래스에서만 사용가능하고
    하위 클래스에서는 사용할 수가 없습니다.

  - super 키워드에 대해 설명해주세요

    super을 사용하면 상위 클래스의 constructor을 호출합니다.

  - [new.target](http://new.target) 키워드는 언제 사용될까요?

    함수 호출에서 new.target은 new를 이용해서 함수를 호출했는지에 대한 정보를 얻습니다. 생성자 함수로 사용하려고 했지만 new를 사용하지 않았을 경우 에러처리가 가능합니다.
    클래스에서의 new.target은 인스턴스화된 해당 클래스를 반환합니다.

  - instanceof는 어떤 상황일 때 사용하는 걸까요?

    우 변의 생성자 함수의 prototype에 좌변의 객체가 바인딩 되어있는지를 확인합니다. 프로토타입 체인상 각 생성자 함수와 객체가 연관이 있는지를 확인할 수 있씁니다.

- promise, async, await

  - promise란 무엇일까요?
  - 자바스크립트에서 promise는 무엇을 의미할까요?

    Promise는 비동기적 처리의 성공/실패 여부에 따라서 작동하는 객체로 비동기 처리에 사용됩니다.

  - promise는 어떤 상태를 갖게 되나요?

    promise는 처리중인 Pending, 완료된 Fullfilled, 실패하거나 오류가 생긴 Rejected의 상태를 가집니다.

  - promise는 thenable하다 라는 표현이 있는데요.
    thenable이라 불릴 수 있기 위한 조건은 어떻게 될까요?

    thenable은 then 함수를 매서드로 가지는 객체로 then 매서드는 성공할 떄와, 실패할 때 실행할 함수를 인자로 받습니다.

  - promise.all과 promise.race를 설명해보세요

    promise.all은 모든 promise객체들이 완료된 후 실행되고
    promise.race는 가장 빨리 끝난 promise를 반환합니다.

  - async/await 구문은 왜 사용하는 걸까요?

    promise와 같은 비동기 처리를 좀 더 쉽게 사용하기 위해 만들어졌습니다.

  - async 함수 내에서 비동기 요청을 병렬로 진행하기 위해서는 어떻게 해야할까요?

    async 내에서 Promise.all을 사용하면 됩니다.

- 제너레이터, 이터러블, 이터레이터

  - 이터레이터란 무엇인가요?

    이터레이터는 next 메소드를 이용하여 순환할 수 있는 객체입니다.

  - 이터러블 객체는 어떤 조건을 만족하는 객체일까요?

    이터러블은 객체의 맴버를 반복할 수 있는 객체이며 이를 가능하게 하려면
    Symbol.iterator이 추가되어야 합니다.

  - 제너레이터는 무엇인가요?

    이터러블을 보다 쉽게 생성하기 위해 만들어진 문법으로
    제네레이터 함수는 이터러블을 생성하는 함수입니다.
    이터러블이면서 이터레이터인 특징을 가지고 있습니다.

    - 어떤 상황에서 사용했을 때 좋은 효과를 볼 수 있을까요?

    제네레이터 함수는 next 메소드가 실행된 후 다음 단계로 넘어가기 떄문에 비동기식 처리가 가능해집니다.

- 이벤트

  - CustomEvent 객체는 어떤 상황에 사용하게 될까요?

    이벤트 핸들러 객체로 이벤트 상황에 따른 함수를 실행할 때 사용 합니다.

  - 이벤트 버블링과 이벤트 캡처링에 대해 이야기해보세요

    이벤트 버블링이란 이벤트가 발생한 경우 여러개의 이벤트가 중첩되어 있으면 하위 노드부터 실행되어 상위 노드의 이벤트를 순차적으로 실행되는 것을 말합니다.

    이벤트 캡처링은 버블링과는 반대로 상위 인스턴스부터 이벤트가 실행되어 하위 인스턴스로 내려가는 방식입니다.

  - async, defer에 대해 설명해주세요
  - 이벤트 위임에 대해 설명해보세요

  여러개의 컴포넌트가 있을 경우 각 컴포넌트에 이벤트를 추가하는 것이 아닌 상위 컴포넌트에서 이벤트 관리를 하는 것을 말합니다.

---
