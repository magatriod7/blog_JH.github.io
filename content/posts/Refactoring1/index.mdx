---
title: Refactoring1
date: 2022-08-20
description: Refactoring1
tags:
  - refactoring
---

## 리팩터링이란?

리팩터링이란 코드의 동작은 유지한 채, 코드를 이해하고 수정하기 쉽게 내부 구조를 변경하는 기법을 말합니다. 즉, 코드를 쉽게 이해하고 수정할 수 있도록 정리를 해두는 것입니다.

단, 리팩터링은 성능 최적화와는 다른 개념입니다. 리팩터링의 과정을 거친 이후에는 그 오히려 속도적인 면에서는 느려질 수도 있습니다.

### 리팩터링을 하는 이유

#### 1. 리팩터링을 하면 소프트웨어 설계가 좋아집니다.

개발을 할 때 소스의 구조를 고려하지 않고 목표만을 위해 코드를 수정하다보면 나중에 구조상 문제가 생기는 경우를 한번씩은 겪어봤을 것입니다.
설령 동작이 잘 되더라도 설계를 파악하기가 힘들어질 것입니다. 정렬되지 않은 소스는 계속 길어질 것이고 너무 길어진 소스는 파악이 힘들어집니다.
이 악영향이 계속 반복되다보면 결국 소스 개발이 힘들어 질 것입니다.

리팩터링을 통해 반복적으로 사용하는 소스코드는 간결하게 만들고(단, 반복적인 소스코드를 줄인다고 해서 작업 시간이 주는 것은 아닙니다.) 대체적으로 냄새나는 코드들을
수정해 코드를 수정을 쉽고 빠르게 할 수 있도록 전체적인 구조적인 설계를 향상시켜야 합니다.

#### 2. 리팩터링을하면 소프트 웨어를 이해하기 쉬워진다.

프로그래밍은 내가 원하는 바를 정확하게 컴퓨터가 실행할 수 있도록 표현하는 것입니다.

하지만 저희가 만든 소스코드는 컴퓨터만 사용하는 것이 아니라
다른 사람, 혹은 6개월 후의 나 자신 등이 소스코드를 수정하거나 개선하기 위해
소스를 살펴볼 수도 있습니다.

만약 저희가 만든 소스코드가 동작시키는 데만 신경쓰다보니 코드를 다룰 다른
개발자를 배려하지 않으면 소스코드를 이해하는데 많은 시간을 들이게 될 것입니다.

리팩터링은 이런 상황에서 보다 명확하게 소스에 대한 정보를 사용자에게 넘겨
코드를 이해하기 쉽게 만들어줍니다.

#### 3. 리팩터링을 하면 버그를 쉽게 찾을 수 있습니다.

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말입니다.

어디서부터 잘못된지 확인할 수 없어 console.log나 print등을 사용해서
주구장창 하나씩 찾아보기는 이제 모두 지쳤을 것입니다.

리팩터링을 이용해서 소스코드의 전체적인 구조를 쉽게 파악하면 버그도 쉽게
찾을 수 있을 것입니다.

#### 4. 리팩터링을하면 프로그래밍 속도를 높일 수 있습니다.

지금까지 말한 리팩터링의 장점을 정리하면 코드 이해 속도를 높여 유지보수, 수정, 추가에 도움을 주고 개발 속도를 향상시킬 수 있다는 것이었습니다.

속도적인 측면에서 리팩터링을 하지 않은 경우가 더 빠른 개발이 가능하지 않을까 하는 생각을 할 수도 있는데 만약 간단한 서비스가 아닌 복잡하고 이미 많은
기능을 가진 코드에 무언가 추가를 하고 싶은 경우라면
일어날 수도 있는 버그와 코드에 필요한 정보를 쉽게 알 수 있는 리펙터링이
개발 속도를 높여줄 것입니다.

### 언제 리팩터링을 해야할까?

refactoring 책의 저자의 말에 따르면 같은 작업을 3번 이상 하게 되거나 보기 싫은 코드가 보이면 리펙터링을 하라고 말했습니다. 그 방법에 대해서는 추후 이야기 하겠습니다.

#### 1. 준비를 위한 리팩터링 기능을 쉽게 추가하게 만들기

리팩터링을 하기 가장 좋은 시점은 새로운 기능을 추가하기 직전입니다.
새로운 기능을 추가히기 전에 코드를 살펴보면서, 구조를 살짝 바꾸면 추후
작업이 더 쉬워질 부분을 찾는 것이 좋습니다. 예를 들어 반복되서 사용되는
코드가 있을 때 나중에 문제가 생길 경우 반복되는 모든 코드들을 변경해야하지만
이를 따로 빼내서 관리하면 코드를 수정하거나 버그가 생길 경우 용이해집니다.

#### 2. 이해를 위한 리팩터링, 코드를 이해하기 쉽게 만들기

코드를 수정하려먼 먼저 코드를 파악해야합니다. 코드를 파악할 사람은
여러분이 아니라 다른 사람일 수도 있습니다. 코드를 이해하기 쉽게 만들기
위해서는 코드의 의도를 명확하게 만들기 위해 구조를 고치고 함수 이름을
상황에 맞게 정하는 방법이 있습니다.

이해하기 쉽게 만들어진 코드들은 기존 정리되지 못했던 코드에서 찾을 수 없었던
설계가 눈에 들어오는 등 기존에 머리 속으로만 시뮬레이션 하기 힘들었던
코드들을 보다 쉽게 문제점을 찾을 수 있을 것입니다.

#### 3. 쓰레기 줍기 리팩터링

코드를 파악하던 중 일을 비효율 적으로 처리하는 모습을 발견할 떄가 있습니다.
하지만 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 투자하기 싫을 수도 있습니다.
이런 경우 간단히 수정할 것은 즉시 고치고 시간이 걸릴 것은 메모를 해둔 후 추후
작업을 하면 됩니다. 이것이 쓰레기 줍기 리팩터링입니다.

#### 4. 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리펙터링은 모두
기회가 있을 때만 진행합니다. 하지만 리팩터링은 이렇게 일정을 잡지 않고
프로그래밍 도중 수시로 하는 것이 좋습니다.

보기 싫은 코드를 발견하면 리팩터링을 해야하고 잘 작성된 코드 또한 리팩터링을 할 필요가 있을겁니다.

수시로 하는 리팩터링의 경우 먼저 수정하기 쉽게 정리하는 것을 목적으로둬 추후 수정이 쉽도록 하게 하는 것이 좋습니다.

#### 5. 리팩터링을 하지 말아야 할 때

굳이 수정할 필요가 없다면 지저분한 코드를 반견해도 리팩터링을 할 필요가 없다.
외부 API를 다루듯 호출해서 사용하는 코드면 지저분해도 그냥 두면 됩니다. 반면, 내부 동작을 이해해야 할 시점에는 리팩터링이 필요할 것입니다.

리팩터링을 하는 것보다 처음부터 새로 작성하는 것이 수운 경우에도 굳이 리팩터링을 할 필요가 없습니다.

어떤 상황에서 리팩터링을 해야할지를 정하는 것이 실력을 판단하는 좋은 예시가 될 것입니다.

### 리팩터링 할 시 고려할 문제

#### 1. 새 기능 개발 속도 저하

리팩터링을 따로 진행하는 것은 궁극적으로 개발 속도를 높이는 목적을 가지지만
별도의 과정을 거치는 점에서 결국 시간을 잡아먹기도 합니다.

결국 리팩터링 사용 유무는 조율이 중요합니다. 새 기능을 추가히기 쉽겠다 생각하는 부분은
리팩터링을 진행하여 추후 작업의 능율을 높이고 굳이 건드릴 필요가 없거나 심하게 불편하지 않은 경우에는
리팩터링을 굳이 할 필요가 없을 것입니다.

리팩터링의 궁극적인 목적이 코드를 예쁘게 꾸미는 것이 아닌 경제적으로 시간을
덜 잡아먹게 하는 것에 있는 만큼 좋은 설계가 필요할 곳을 확실하게 정하는 것이 좋습니다.

#### 2. 코드 소유권

리팩터링을 하다보면 코드의 소유자가 다른 팀이어서 나에게 쓰기 권한이 없을 수도 있습니다.
코드 소유권이 엄격하게 나뉘어 있으면 리팩터링에 방해가 됩니다.

이런 문제를 해결하기 위해서는 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있도록 해야합니다.
프로그래머가 각자의 책임지는 영역이 있다는 말은 자신의 영역의 변경 사항을 관리하라는 말이지
다른 사람이 수정하기 못하게 막으라는 뜻이 아닙니다.

#### 3. 브랜치

현재 흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를
하나씩 맡아서 작업하다가 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합하는 방식입니다.

이렇게 되면 어떤 기능 전체를 한 브랜치에만 구현해두고, 프로덕션 버전으로 릴리스할 때가  돼서야 마스터에 통합하는 경우가 많습니다.
만약 각 소스의 통합의 주기가 너무 길어진다면 이 경우 각 개발의 브랜치가 가져올 리팩터링 부담이 너무
커질 것입니다. 고로 각 개발이 완벽하게 진행되지는 않은 상황이더라도
통합 주기를 짧게 잡아 리펙터링을 할 필요가 있습니다.

#### 4. 테스팅

리펙터링의 특징으로 프로그램의 겉보기 동작은 똑같이 유지된다는 것입니다.
하지만 리펙터링 과정 중 오류가 발생하여 문제가 생길 수도 있습니다.
이 상황을 피하기 위해 자가 테스트 코드를 통해서 버그를 줄일 필요가 있습니다.

#### 5. 레거시 코드

물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많습니다.
무엇보다 다른 사람이 작성한 것입니다. 레거시 시스템을 파악할 때 리펙터링이 괸장히 도움이 됩니다.
제 기능과 맞지 않은 함수를 정렬하고 어설픈 프로그램 구문을 다듬을 필요가 있습니다. 
하지만 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리펙터링 하기는 어렵습니다.






---
